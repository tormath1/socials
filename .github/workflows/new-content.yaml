---
name: Handle New Content
on:
  issues:
    types:
      - opened
      - edited
      - labeled
      - unlabeled

jobs:
  validate:
    # assert we only parse new content issues
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'edited') && contains(github.event.issue.labels.*.name, 'content')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Check for content length
        run: |
          set -x
          cat "${GITHUB_EVENT_PATH}"
          body=$(jq -a -r '.issue.body' "${GITHUB_EVENT_PATH}" | grep -o -P '(?<=Content\\n\\n).*(?=\\n\\n### Link)')
          echo $body

          # 280 characters for the X limit
          above_limit=false
          if [ ${#body} -ge 280 ]; then
            above_limit=true
          fi

          if [ "$above_limit" = true ]; then
            # comment on the issue that we are above the limit.
            gh issue comment "$NUMBER" --body "$BODY"

            # exit with an exitcode different from 0 to make the dependency fail.
            exit 1
          fi

        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          NUMBER: ${{ github.event.issue.number }}
          BODY: >
            The length of this content is above the X limit (280 characters).

  content:
    # assert we only parse new content issues
    if: contains(github.event.issue.labels.*.name, 'content')
    runs-on: ubuntu-latest
    needs:
      - validate
    steps:
      - uses: actions/checkout@v4

      - id: issue-event
        run: |
          # Extract the issue author and the number of the issue
          user=$(jq -r '.issue.user.login' ${GITHUB_EVENT_PATH})
          number=$(jq -r '.issue.number' ${GITHUB_EVENT_PATH})

          # Extract the body (what's between Content and Link)
          body=$(jq -a -r '.issue.body' "${GITHUB_EVENT_PATH}" | grep -o -P '(?<=Content\\n\\n).*(?=\\n\\n### Link)')
          # Extract the link (what's between Link and the last linefeed)
          link=$(jq -a -r '.issue.body' "${GITHUB_EVENT_PATH}" | grep -o -P '(?<=Link\\n\\n).*(?=\")')

          # Inject the issue author and the number of the issue into the GITHUB_OUTPUT
          # to be later reused.
          echo "user=${user}" >> "${GITHUB_OUTPUT}"
          echo "number=${number}" >> "${GITHUB_OUTPUT}"

          # Prepare the content of the PR:
          # The title, the content and the label of the issue will be archived in the 'published' folder
          jq -r '.issue.title' "${GITHUB_EVENT_PATH}" > ./published/"${number}-${user}.md"
          echo >> ./published/"${number}-${user}.md"
          echo "### Content"
          echo "${body}" >> ./published/"${number}-${user}.md"
          echo >> ./published/"${number}-${user}.md"
          echo "${link}" >> ./published/"${number}-${user}.md"
          echo >> ./published/"${number}-${user}.md"
          jq -r '[ .issue.labels[] | select(.name != "content") | .name ] | join(", ")' "${GITHUB_EVENT_PATH}" >> ./published/"${number}-${user}.md"

      - uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: "${{ steps.issue-event.outputs.user }}/content-${{ steps.issue-event.outputs.number }}"
          path: .
          title: "new content from: ${{ steps.issue-event.outputs.user }}"
          body: |
            Hi folks, I would like to propose the following content to share on Flatcar social networks.

            Closes: #${{ steps.issue-event.outputs.number }}
          commit-message: "new content: #${{ steps.issue-event.outputs.number }}"
          committer: "Flatcar Buildbot <buildbot@flatcar-linux.org>"
          author: "Flatcar Buildbot <buildbot@flatcar-linux.org>"
          signoff: true
